var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = MicMods","category":"page"},{"location":"#MicMods","page":"Home","title":"MicMods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MicMods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [MicMods]","category":"page"},{"location":"#MicMods.LabeledParSetter","page":"Home","title":"MicMods.LabeledParSetter","text":"LabeledParSetter\n\nTranslates between a vector of optimization parameters and the two vectors of a system: its parameters and initial states.\n\n\n\n\n\n","category":"type"},{"location":"#MicMods.LabeledParSetter-Tuple{NamedTuple}","page":"Home","title":"MicMods.LabeledParSetter","text":"LabeledParSetter(\n    systemt, \n    paropt = keys(systemt.searchranges_p), \n    stateopt = keys(systemt.searchranges_u0))\n\nConstruct a Parameter-Setter based on the subset of parameters and initial states.   \n\n\n\n\n\n","category":"method"},{"location":"#MicMods.ParSetter","page":"Home","title":"MicMods.ParSetter","text":"ParSetter\n\nTranslates between a vector of optimization parameters and the two vectors of a system: its parameters and initial states.\n\n\n\n\n\n","category":"type"},{"location":"#MicMods.ParSetter-Tuple{AbstractVector{Symbolics.Num}, AbstractVector{Symbolics.Num}, Any, Any}","page":"Home","title":"MicMods.ParSetter","text":"ParSetter(parsys,statesys,paropt,stateopt)\n\nConstruct a Parameter-Setter based on the subset of parameters and initial states.        \n\nvalues\n\nAll arguments are of type AbstractVector{Num}\n\nparsys,statesys: parameters and states of the system\nparopt,stateopt: parameters and states in optimization vector\n\n\n\n\n\n","category":"method"},{"location":"#MicMods.ParSetter-Tuple{NamedTuple}","page":"Home","title":"MicMods.ParSetter","text":"ParSetter(\n    systemt, \n    paropt = keys(systemt.searchranges_p), \n    stateopt = keys(systemt.searchranges_u0))\n\nConstruct a Parameter-Setter based on the subset of parameters and initial states.        \n\n\n\n\n\n","category":"method"},{"location":"#MicMods.estimate_u0_from_cumresp-Union{Tuple{replace_u0}, NTuple{5, Any}, Tuple{Any, Any, Any, Any, Any, Val{replace_u0}}} where replace_u0","page":"Home","title":"MicMods.estimate_u0_from_cumresp","text":"estimate_u0_from_cumresp(tinfl, popt0, systemt, chak21syn; ps = LabelledParSetter(systemt))\n\nObtain initial estimate of substrate s and biomass u by computing uptake from microbial parameters and respiration.\n\nArguments\n\ntinfl: (numeric) start-time, after amendment\nu0: labelled array of initial state with entries s and b\nb0: microbial biomass at amendmend time 0. The default is obtained from chak21syn problem\nt, r_tot: respiration rate measured at time t\nr0, Y: representative phyisological state and yield for the period 0..tinfl.\n\nValue\n\nTuple (u0, cr_tot_gr) of parameters and cumulated respiration.\n\n\n\n\n\n","category":"method"},{"location":"#MicMods.extendrange","page":"Home","title":"MicMods.extendrange","text":"extendrange(lower,upper, frac = 0.1)\n\nModify lower and upper to so that the included range is extended by frac.\n\nThis is useful for settting plotting limits based on quantiles.\n\n\n\n\n\n","category":"function"},{"location":"#MicMods.find_inflection-Tuple{Any, Any}","page":"Home","title":"MicMods.find_inflection","text":"find_inflection(y,y)\n\nFind the inflection point in the first increase where the slope is maximum.    \n\nArguments\n\ny,y: numeric vectors to fit relationship\n\nExamples\n\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#MicMods.getpopt-Union{Tuple{Labeled}, Tuple{LabeledParSetter, Any}, Tuple{LabeledParSetter, Any, Val{Labeled}}} where Labeled","page":"Home","title":"MicMods.getpopt","text":"getpopt(ps::LabeledParSetter, prob)\n\nExtract the parameter vector from prob.p and prob.u0.\n\nValue: Numeric array.\n\n\n\n\n\n","category":"method"},{"location":"#MicMods.getpopt-Union{Tuple{Labeled}, Tuple{ParSetter, Any}, Tuple{ParSetter, Any, Val{Labeled}}} where Labeled","page":"Home","title":"MicMods.getpopt","text":"getpopt(ps::ParSetter, prob)\n\nExtract the parameter vector from prob.p and prob.u0.\n\nValue: Numeric array.\n\n\n\n\n\n","category":"method"},{"location":"#MicMods.kinresp_exp-Tuple{}","page":"Home","title":"MicMods.kinresp_exp","text":"Fit exponential equation with lognormal priors on coefficients.\n\n\n\n\n\n","category":"method"},{"location":"#MicMods.kinresp_mic-Tuple{}","page":"Home","title":"MicMods.kinresp_mic","text":"Fit the kinetic respiraiton model using microbial parameters\n\n\n\n\n\n","category":"method"},{"location":"#MicMods.label_parsys-Tuple{ParSetter, Any}","page":"Home","title":"MicMods.label_parsys","text":"label_parsys(ps::ParSetter, popt)\n\nCreate an LVector from parameter vector\n\n\n\n\n\n","category":"method"},{"location":"#MicMods.label_parsys-Union{Tuple{ST}, Tuple{PAR}, Tuple{LabeledParSetter{PAR, ST}, Any}} where {PAR, ST}","page":"Home","title":"MicMods.label_parsys","text":"label_parsys(ps::LabeledParSetter, popt)\n\nCreate an LVector from parameter vector\n\n\n\n\n\n","category":"method"},{"location":"#MicMods.label_popt-Tuple{ParSetter, Any}","page":"Home","title":"MicMods.label_popt","text":"label_popt(ps::ParSetter, popt)\n\nCreate an LVector from parameter vector\n\n\n\n\n\n","category":"method"},{"location":"#MicMods.label_popt-Union{Tuple{NSO}, Tuple{NPO}, Tuple{NS}, Tuple{NP}, Tuple{SOPT}, Tuple{POPT}, Tuple{ST}, Tuple{PAR}, Tuple{LabeledParSetter{PAR, ST, POPT, SOPT, NP, NS, NPO, NSO}, Any}} where {PAR, ST, POPT, SOPT, NP, NS, NPO, NSO}","page":"Home","title":"MicMods.label_popt","text":"label_popt(ps::LabeledParSetter, popt)\n\nCreate an LVector from parameter vector\n\n\n\n\n\n","category":"method"},{"location":"#MicMods.label_statesys-Tuple{ParSetter, Any}","page":"Home","title":"MicMods.label_statesys","text":"label_parsys(ps::ParSetter, popt)\n\nCreate an LVector from parameter vector\n\n\n\n\n\n","category":"method"},{"location":"#MicMods.label_statesys-Union{Tuple{ST}, Tuple{PAR}, Tuple{LabeledParSetter{PAR, ST}, Any}} where {PAR, ST}","page":"Home","title":"MicMods.label_statesys","text":"label_parsys(ps::LabeledParSetter, popt)\n\nCreate an LVector from parameter vector\n\n\n\n\n\n","category":"method"},{"location":"#MicMods.micfromcoef-Tuple{Any}","page":"Home","title":"MicMods.micfromcoef","text":"micfromcoef(params; λ = 0.9, YCO2 = 1.5)\n\nCompute microbial parameters from coefficient regressions β0,β1,β2. See Wutzler11 eq. (2,3,4)\n\nValue: Numeric array: [μmax, r0, x0, λ, YCO2]\n\n\n\n\n\n","category":"method"},{"location":"#MicMods.parindex-Tuple{ParSetter, Symbol}","page":"Home","title":"MicMods.parindex","text":"parindex(ps::ParSetter, sym::Symbol)\n\nGet the index corresponding to symbol in vector of system parameters.\n\nValue: Integer or nothing\n\n\n\n\n\n","category":"method"},{"location":"#MicMods.replacetby0-Tuple{Any}","page":"Home","title":"MicMods.replacetby0","text":"replace \"(t)\" in sting vector by \"_0\"\n\nTo create parameter names, that MCMCChains.get can handle. get(chn, Symbol(\"b(t)\") is not extracted.\n\n\n\n\n\n","category":"method"},{"location":"#MicMods.setpu-Union{Tuple{Labeled}, Tuple{LabeledParSetter, Any, Any}, Tuple{LabeledParSetter, Any, Any, Val{Labeled}}} where Labeled","page":"Home","title":"MicMods.setpu","text":"setpu(ps::LabeledParSetter, popt, prob)\nsetpu(ps::LabeledParSetter, popt, p, u0)\n\nSet values in tuple (prob.p, prob.u0) to popt.\n\nEltype of new p and u0 should correspond to type of popt, while vector type should correspond to original p and u0. If p is of type SVector{3,Float64} and eltype(popt) == Dual128, then new p is of type SVector{3,Dual128}.\n\nValue: Tuple (p, u0)\n\n\n\n\n\n","category":"method"},{"location":"#MicMods.setpu-Union{Tuple{Labeled}, Tuple{ParSetter, Any, Any}, Tuple{ParSetter, Any, Any, Val{Labeled}}} where Labeled","page":"Home","title":"MicMods.setpu","text":"setpu(ps::ParSetter, popt, prob)\nsetpu(ps::ParSetter, popt, p, u0)\n\nSet values in tuple (prob.p, prob.u0) to popt.\n\nEltype of new p and u0 should correspond to type of popt, while vector type should correspond to original p and u0. If p is of type SVector{3,Float64} and eltype(popt) == Dual128, then new p is of type SVector{3,Dual128}.\n\nValue: Tuple (p, u0)\n\n\n\n\n\n","category":"method"},{"location":"#MicMods.stateindex-Tuple{ParSetter, Symbol}","page":"Home","title":"MicMods.stateindex","text":"stateindex(ps::ParSetter, sym::Symbol)\n\nGet the index corresponding to symbol in vector of system states.\n\nValue: Integer or nothing\n\n\n\n\n\n","category":"method"}]
}
